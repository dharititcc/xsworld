<?php

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;

/**
 * Henerate UUID.
 *
 * @return uuid
 */
function generateUuid()
{
    return Str::uuid();
}

if (! function_exists('home_route')) {
    /**
     * Return the route to the "home" page depending on authentication/authorization status.
     *
     * @return string
     */
    function home_route()
    {
        return 'dashboard';
    }
}

// Global helpers file with misc functions.
if (! function_exists('app_name')) {
    /**
     * Helper to grab the application name.
     *
     * @return mixed
     */
    function app_name()
    {
        return config('app.name');
    }
}

if (! function_exists('access')) {
    /**
     * Access (lol) the Access:: facade as a simple function.
     */
    function access()
    {
        return app('access');
    }
}

if (! function_exists('common')) {
    /**
     * Access (lol) the Access:: facade as a simple function.
     */
    function common()
    {
        return app('common');
    }
}

if (! function_exists('history')) {
    /**
     * Access the history facade anywhere.
     */
    function history()
    {
        return app('history');
    }
}

if (! function_exists('gravatar')) {
    /**
     * Access the gravatar helper.
     */
    function gravatar()
    {
        return app('gravatar');
    }
}

if (! function_exists('getRtlCss')) {
    /**
     * The path being passed is generated by Laravel Mix manifest file
     * The webpack plugin takes the css filenames and appends rtl before the .css extension
     * So we take the original and place that in and send back the path.
     *
     * @param $path
     *
     * @return string
     */
    function getRtlCss($path)
    {
        $path = explode('/', $path);
        $filename = end($path);
        array_pop($path);
        $filename = rtrim($filename, '.css');

        return implode('/', $path).'/'.$filename.'.rtl.css';
    }
}

if (! function_exists('escapeSlashes')) {
    /**
     * Access the escapeSlashes helper.
     */
    function escapeSlashes($path)
    {
        $path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
        $path = str_replace('//', DIRECTORY_SEPARATOR, $path);
        $path = trim($path, DIRECTORY_SEPARATOR);

        return $path;
    }
}

if (! function_exists('checkDatabaseConnection')) {
    /**
     * @return bool
     */
    function checkDatabaseConnection()
    {
        try {
            DB::connection()->reconnect();

            return true;
        } catch (Exception $ex) {
            return false;
        }
    }
}

if (! function_exists('getShortDescription')) {
    // Don't change the default value
    function getShortDescription(?string $text, bool $lineBreak = true, int $length = 500): ?string
    {
        if (empty($text)) {
            return $text;
        }

        $text = mb_strlen($text) > $length
            ? mb_substr($text, 0, $length - 3) . '...'
            : $text;

        return $lineBreak ? getLineBreakOnly($text) : $text;
    }
}

if (! function_exists('getLineBreakOnly')) {
    function getLineBreakOnly(?string $text): ?string
    {
        if (empty($text)) {
            return $text;
        }

        return nl2br(e($text));
    }
}

if (! function_exists('displayViewMore')) {
    // Don't change the default value
    function displayViewMore(?string $text, int $length = 500): bool
    {
        if (empty($text)) {
            return false;
        }

        return mb_strlen($text) > $length;
    }
}

if (! function_exists('urlWithScheme')) {
    function urlWithScheme(?string $url, bool $https = false): ?string
    {
        if (empty($url)) {
            return null;
        }

        $urlInfo = parse_url($url);

        if (!isset($urlInfo['scheme'])) {
            if ($https) {
                $url = 'https://' . $url;
            } else {
                $url = 'http://' . $url;
            }
        }

        return $url;
    }
}

if (! function_exists('generateUniqueModelSlug')) {
    /**
     * Generate Unique Model Slug
     *
     * @param Model $model
     * @param string $slugAttribute
     * @param string $slugField
     * @param int $counter
     * @return string
     */
    function generateUniqueModelSlug(
        Model $model, // Model instance
        string $slugAttribute = 'title', // Accessor or attribute which will be used to identify value
        string $slugField = 'slug', // DB field used to check unique value in the database
        int $counter = 1 // Suffix number
    ): string
    {
        $nameSlug = Str::slug($model->{$slugAttribute});

        // Apply counter initially
        $slug = $nameSlug . '-' . $counter;

        // Fetch all slugs
        $allSlugs = $model->select($slugField)->withTrashed()->pluck($slugField)->toArray();

        // Check in array instead of checking in database to improve the performance
        while (in_array($slug, $allSlugs)) {
            $slug = $nameSlug . '-' . $counter;

            $counter++;
        }

        // Do final check in the DB
        $exists = $model->withTrashed()->where($slugField, $slug)->exists();

        if (!$exists) {
            return $slug;
        }

        // Recursive call to the function unless a unique counter is generated
        return generateUniqueModelSlug($model, $slugAttribute, $slugField, $counter);
    }
}